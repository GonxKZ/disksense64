#include \"file_utils.h\"\n#include <iostream>\n#include <algorithm>\n#include <filesystem>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n\n#ifdef _WIN32\n#include <windows.h>\n#include <shlwapi.h>\n#include <shlobj.h>\n#else\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <pwd.h>\n#include <limits.h>\n#endif\n\n// FileUtils implementation\nfile_handle_t FileUtils::open_file(const std::string& path, bool read_only) {\n#ifdef _WIN32\n    std::wstring wpath(path.begin(), path.end());\n    \n    DWORD access = read_only ? GENERIC_READ : (GENERIC_READ | GENERIC_WRITE);\n    DWORD share_mode = FILE_SHARE_READ | FILE_SHARE_WRITE;\n    DWORD creation = read_only ? OPEN_EXISTING : OPEN_ALWAYS;\n    DWORD flags = FILE_ATTRIBUTE_NORMAL;\n    \n    if (!read_only) {\n        flags |= FILE_FLAG_WRITE_THROUGH;\n    }\n    \n    HANDLE handle = CreateFileW(\n        wpath.c_str(),\n        access,\n        share_mode,\n        nullptr,\n        creation,\n        flags,\n        nullptr\n    );\n    \n    return handle;\n#else\n    int flags = read_only ? O_RDONLY : (O_RDWR | O_CREAT);\n    int fd = open(path.c_str(), flags, 0644);\n    return fd;\n#endif\n}\n\nvoid FileUtils::close_file(file_handle_t handle) {\n    if (!is_valid_handle(handle)) {\n        return;\n    }\n    \n#ifdef _WIN32\n    CloseHandle(handle);\n#else\n    close(handle);\n#endif\n}\n\nbool FileUtils::is_valid_handle(file_handle_t handle) {\n#ifdef _WIN32\n    return handle != INVALID_FILE_HANDLE && handle != nullptr;\n#else\n    return handle != INVALID_FILE_HANDLE;\n#endif\n}\n\nuint64_t FileUtils::get_file_size(file_handle_t handle) {\n    if (!is_valid_handle(handle)) {\n        return 0;\n    }\n    \n#ifdef _WIN32\n    LARGE_INTEGER size;\n    if (GetFileSizeEx(handle, &size)) {\n        return static_cast<uint64_t>(size.QuadPart);\n    }\n#else\n    struct stat st;\n    if (fstat(handle, &st) == 0) {\n        return static_cast<uint64_t>(st.st_size);\n    }\n#endif\n    \n    return 0;\n}\n\nbool FileUtils::read_file_data(file_handle_t handle, void* buffer, size_t size, uint64_t offset) {\n    if (!is_valid_handle(handle) || !buffer || size == 0) {\n        return false;\n    }\n    \n#ifdef _WIN32\n    LARGE_INTEGER liOffset;\n    liOffset.QuadPart = offset;\n    if (!SetFilePointerEx(handle, liOffset, nullptr, FILE_BEGIN)) {\n        return false;\n    }\n    \n    DWORD bytesRead = 0;\n    BOOL result = ReadFile(handle, buffer, static_cast<DWORD>(size), &bytesRead, nullptr);\n    return result && bytesRead == size;\n#else\n    off_t seekResult = lseek(handle, static_cast<off_t>(offset), SEEK_SET);\n    if (seekResult == -1) {\n        return false;\n    }\n    \n    ssize_t readResult = read(handle, buffer, size);\n    return readResult == static_cast<ssize_t>(size);\n#endif\n}\n\nbool FileUtils::write_file_data(file_handle_t handle, const void* buffer, size_t size, uint64_t offset) {\n    if (!is_valid_handle(handle) || !buffer || size == 0) {\n        return false;\n    }\n    \n#ifdef _WIN32\n    LARGE_INTEGER liOffset;\n    liOffset.QuadPart = offset;\n    if (!SetFilePointerEx(handle, liOffset, nullptr, FILE_BEGIN)) {\n        return false;\n    }\n    \n    DWORD bytesWritten = 0;\n    BOOL result = WriteFile(handle, buffer, static_cast<DWORD>(size), &bytesWritten, nullptr);\n    return result && bytesWritten == size;\n#else\n    off_t seekResult = lseek(handle, static_cast<off_t>(offset), SEEK_SET);\n    if (seekResult == -1) {\n        return false;\n    }\n    \n    ssize_t writeResult = write(handle, buffer, size);\n    return writeResult == static_cast<ssize_t>(size);\n#endif\n}\n\nbool FileUtils::get_file_info(const std::string& path, file_info_t& info) {\n    info = file_info_t(); // Reset info\n    \n#ifdef _WIN32\n    std::wstring wpath(path.begin(), path.end());\n    WIN32_FILE_ATTRIBUTE_DATA attrs;\n    if (!GetFileAttributesExW(wpath.c_str(), GetFileExInfoStandard, &attrs)) {\n        return false;\n    }\n    \n    info.name = path.substr(path.find_last_of(\"/\\\\\") + 1);\n    info.full_path = path;\n    info.size = (static_cast<uint64_t>(attrs.nFileSizeHigh) << 32) | attrs.nFileSizeLow;\n    info.is_directory = (attrs.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0;\n    info.is_symlink = (attrs.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) != 0;\n    info.attributes = attrs.dwFileAttributes;\n    \n    // Convert FILETIME to uint64_t\n    info.creation_time = (static_cast<uint64_t>(attrs.ftCreationTime.dwHighDateTime) << 32) | \n                        attrs.ftCreationTime.dwLowDateTime;\n    info.last_write_time = (static_cast<uint64_t>(attrs.ftLastWriteTime.dwHighDateTime) << 32) | \n                          attrs.ftLastWriteTime.dwLowDateTime;\n    info.last_access_time = (static_cast<uint64_t>(attrs.ftLastAccessTime.dwHighDateTime) << 32) | \n                           attrs.ftLastAccessTime.dwLowDateTime;\n    info.change_time = info.last_write_time; // Windows doesn't have change time\n#else\n    struct stat st;\n    if (stat(path.c_str(), &st) != 0) {\n        return false;\n    }\n    \n    info.name = path.substr(path.find_last_of('/') + 1);\n    info.full_path = path;\n    info.size = static_cast<uint64_t>(st.st_size);\n    info.is_directory = S_ISDIR(st.st_mode);\n    info.is_symlink = S_ISLNK(st.st_mode);\n    info.permissions = st.st_mode;\n    \n    info.creation_time = static_cast<uint64_t>(st.st_ctime);\n    info.last_write_time = static_cast<uint64_t>(st.st_mtime);\n    info.last_access_time = static_cast<uint64_t>(st.st_atime);\n    info.change_time = static_cast<uint64_t>(st.st_ctime);\n#endif\n    \n    return true;\n}\n\nstd::vector<file_info_t> FileUtils::list_directory(const std::string& path) {\n    std::vector<file_info_t> files;\n    \n#ifdef _WIN32\n    std::wstring wpath = std::wstring(path.begin(), path.end()) + L\"\\\\*\";\n    WIN32_FIND_DATAW findData;\n    HANDLE hFind = FindFirstFileW(wpath.c_str(), &findData);\n    \n    if (hFind == INVALID_HANDLE_VALUE) {\n        return files;\n    }\n    \n    do {\n        // Skip . and ..\n        if (wcscmp(findData.cFileName, L\".\") == 0 || wcscmp(findData.cFileName, L\"..\") == 0) {\n            continue;\n        }\n        \n        std::string fileName(findData.cFileName, findData.cFileName + wcslen(findData.cFileName));\n        std::string fullPath = path + \"\\\\\" + fileName;\n        \n        file_info_t info;\n        info.name = fileName;\n        info.full_path = fullPath;\n        info.size = (static_cast<uint64_t>(findData.nFileSizeHigh) << 32) | findData.nFileSizeLow;\n        info.is_directory = (findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0;\n        info.is_symlink = (findData.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) != 0;\n        info.attributes = findData.dwFileAttributes;\n        \n        // Convert FILETIME to uint64_t\n        info.creation_time = (static_cast<uint64_t>(findData.ftCreationTime.dwHighDateTime) << 32) | \n                            findData.ftCreationTime.dwLowDateTime;\n        info.last_write_time = (static_cast<uint64_t>(findData.ftLastWriteTime.dwHighDateTime) << 32) | \n                              findData.ftLastWriteTime.dwLowDateTime;\n        info.last_access_time = (static_cast<uint64_t>(findData.ftLastAccessTime.dwHighDateTime) << 32) | \n                               findData.ftLastAccessTime.dwLowDateTime;\n        info.change_time = info.last_write_time; // Windows doesn't have change time\n        \n        files.push_back(info);\n    } while (FindNextFileW(hFind, &findData));\n    \n    FindClose(hFind);\n#else\n    DIR* dir = opendir(path.c_str());\n    if (!dir) {\n        return files;\n    }\n    \n    struct dirent* entry;\n    while ((entry = readdir(dir)) != nullptr) {\n        // Skip . and ..\n        if (strcmp(entry->d_name, \".\") == 0 || strcmp(entry->d_name, \"..\") == 0) {\n            continue;\n        }\n        \n        std::string fullPath = path + \"/\" + entry->d_name;\n        \n        struct stat st;\n        if (stat(fullPath.c_str(), &st) != 0) {\n            continue;\n        }\n        \n        file_info_t info;\n        info.name = entry->d_name;\n        info.full_path = fullPath;\n        info.size = static_cast<uint64_t>(st.st_size);\n        info.is_directory = S_ISDIR(st.st_mode);\n        info.is_symlink = S_ISLNK(st.st_mode);\n        info.permissions = st.st_mode;\n        \n        info.creation_time = static_cast<uint64_t>(st.st_ctime);\n        info.last_write_time = static_cast<uint64_t>(st.st_mtime);\n        info.last_access_time = static_cast<uint64_t>(st.st_atime);\n        info.change_time = static_cast<uint64_t>(st.st_ctime);\n        \n        files.push_back(info);\n    }\n    \n    closedir(dir);\n#endif\n    \n    return files;\n}\n\nbool FileUtils::create_directory(const std::string& path) {\n#ifdef _WIN32\n    std::wstring wpath(path.begin(), path.end());\n    return CreateDirectoryW(wpath.c_str(), nullptr) != FALSE || \n           GetLastError() == ERROR_ALREADY_EXISTS;\n#else\n    return mkdir(path.c_str(), 0755) == 0 || errno == EEXIST;\n#endif\n}\n\nbool FileUtils::delete_file(const std::string& path) {\n#ifdef _WIN32\n    std::wstring wpath(path.begin(), path.end());\n    return DeleteFileW(wpath.c_str()) != FALSE;\n#else\n    return unlink(path.c_str()) == 0;\n#endif\n}\n\nbool FileUtils::move_file(const std::string& source, const std::string& destination) {\n#ifdef _WIN32\n    std::wstring wsource(source.begin(), source.end());\n    std::wstring wdestination(destination.begin(), destination.end());\n    return MoveFileW(wsource.c_str(), wdestination.c_str()) != FALSE;\n#else\n    return rename(source.c_str(), destination.c_str()) == 0;\n#endif\n}\n\nbool FileUtils::copy_file(const std::string& source, const std::string& destination) {\n#ifdef _WIN32\n    std::wstring wsource(source.begin(), source.end());\n    std::wstring wdestination(destination.begin(), destination.end());\n    return CopyFileW(wsource.c_str(), wdestination.c_str(), FALSE) != FALSE;\n#else\n    // Simple file copy implementation\n    std::ifstream src(source, std::ios::binary);\n    std::ofstream dst(destination, std::ios::binary);\n    dst << src.rdbuf();\n    return src.good() && dst.good();\n#endif\n}\n\nbool FileUtils::path_exists(const std::string& path) {\n#ifdef _WIN32\n    std::wstring wpath(path.begin(), path.end());\n    return GetFileAttributesW(wpath.c_str()) != INVALID_FILE_ATTRIBUTES;\n#else\n    return access(path.c_str(), F_OK) == 0;\n#endif\n}\n\nbool FileUtils::is_directory(const std::string& path) {\n#ifdef _WIN32\n    std::wstring wpath(path.begin(), path.end());\n    DWORD attrs = GetFileAttributesW(wpath.c_str());\n    return attrs != INVALID_FILE_ATTRIBUTES && (attrs & FILE_ATTRIBUTE_DIRECTORY) != 0;\n#else\n    struct stat st;\n    return stat(path.c_str(), &st) == 0 && S_ISDIR(st.st_mode);\n#endif\n}\n\nbool FileUtils::is_file(const std::string& path) {\n#ifdef _WIN32\n    std::wstring wpath(path.begin(), path.end());\n    DWORD attrs = GetFileAttributesW(wpath.c_str());\n    return attrs != INVALID_FILE_ATTRIBUTES && (attrs & FILE_ATTRIBUTE_DIRECTORY) == 0;\n#else\n    struct stat st;\n    return stat(path.c_str(), &st) == 0 && S_ISREG(st.st_mode);\n#endif\n}\n\nchar FileUtils::get_path_separator() {\n#ifdef _WIN32\n    return '\\\\';\n#else\n    return '/';\n#endif\n}\n\nstd::string FileUtils::join_paths(const std::string& path1, const std::string& path2) {\n    if (path1.empty()) return path2;\n    if (path2.empty()) return path1;\n    \n    char separator = get_path_separator();\n    \n    if (path1.back() == separator) {\n        return path1 + path2;\n    }\n    \n    return path1 + separator + path2;\n}\n\nstd::string FileUtils::get_file_extension(const std::string& path) {\n    size_t dot_pos = path.find_last_of('.');\n    if (dot_pos != std::string::npos) {\n        return path.substr(dot_pos);\n    }\n    return \"\";\n}\n\nstd::string FileUtils::to_platform_path(const std::string& path) {\n#ifdef _WIN32\n    std::string result = path;\n    std::replace(result.begin(), result.end(), '/', '\\\\');\n    return result;\n#else\n    std::string result = path;\n    std::replace(result.begin(), result.end(), '\\\\', '/');\n    return result;\n#endif\n}\n\nstd::string FileUtils::get_parent_directory(const std::string& path) {\n    size_t pos = path.find_last_of(\"/\\\\\");\n    if (pos != std::string::npos) {\n        return path.substr(0, pos);\n    }\n    return \"\";\n}\n\nstd::string FileUtils::get_file_name(const std::string& path) {\n    size_t pos = path.find_last_of(\"/\\\\\");\n    if (pos != std::string::npos) {\n        return path.substr(pos + 1);\n    }\n    return path;\n}\n\nstd::string FileUtils::get_absolute_path(const std::string& path) {\n#ifdef _WIN32\n    std::wstring wpath(path.begin(), path.end());\n    wchar_t abs_path[MAX_PATH];\n    if (GetFullPathNameW(wpath.c_str(), MAX_PATH, abs_path, nullptr)) {\n        return std::string(abs_path, abs_path + wcslen(abs_path));\n    }\n    return path;\n#else\n    char abs_path[PATH_MAX];\n    if (realpath(path.c_str(), abs_path)) {\n        return std::string(abs_path);\n    }\n    return path;\n#endif\n}\n\nstd::string FileUtils::normalize_path(const std::string& path) {\n    std::string normalized = to_platform_path(path);\n    \n    // Remove double separators\n    char separator = get_path_separator();\n    std::string double_sep(2, separator);\n    size_t pos;\n    while ((pos = normalized.find(double_sep)) != std::string::npos) {\n        normalized.replace(pos, 2, std::string(1, separator));\n    }\n    \n    return normalized;\n}\n\nstd::string FileUtils::get_temp_directory() {\n#ifdef _WIN32\n    wchar_t temp_path[MAX_PATH];\n    if (GetTempPathW(MAX_PATH, temp_path)) {\n        return std::string(temp_path, temp_path + wcslen(temp_path));\n    }\n    return \"C:\\\\temp\";\n#else\n    const char* tmpdir = getenv(\"TMPDIR\");\n    if (tmpdir) {\n        return std::string(tmpdir);\n    }\n    return \"/tmp\";\n#endif\n}\n\nstd::string FileUtils::get_home_directory() {\n#ifdef _WIN32\n    wchar_t home_path[MAX_PATH];\n    if (SUCCEEDED(SHGetFolderPathW(nullptr, CSIDL_PROFILE, nullptr, SHGFP_TYPE_CURRENT, home_path))) {\n        return std::string(home_path, home_path + wcslen(home_path));\n    }\n    return \"C:\\\\Users\";\n#else\n    struct passwd *pw = getpwuid(getuid());\n    if (pw) {\n        return std::string(pw->pw_dir);\n    }\n    const char* home = getenv(\"HOME\");\n    if (home) {\n        return std::string(home);\n    }\n    return \"/home\";\n#endif\n}\n\nstd::string FileUtils::get_current_directory() {\n#ifdef _WIN32\n    wchar_t current_path[MAX_PATH];\n    if (GetCurrentDirectoryW(MAX_PATH, current_path)) {\n        return std::string(current_path, current_path + wcslen(current_path));\n    }\n    return \"\";\n#else\n    char current_path[PATH_MAX];\n    if (getcwd(current_path, sizeof(current_path))) {\n        return std::string(current_path);\n    }\n    return \"\";\n#endif\n}\n\nbool FileUtils::set_current_directory(const std::string& path) {\n#ifdef _WIN32\n    std::wstring wpath(path.begin(), path.end());\n    return SetCurrentDirectoryW(wpath.c_str()) != FALSE;\n#else\n    return chdir(path.c_str()) == 0;\n#endif\n}\n\nuint64_t FileUtils::get_available_space(const std::string& path) {\n#ifdef _WIN32\n    ULARGE_INTEGER free_bytes;\n    std::wstring wpath(path.begin(), path.end());\n    if (GetDiskFreeSpaceExW(wpath.c_str(), &free_bytes, nullptr, nullptr)) {\n        return free_bytes.QuadPart;\n    }\n    return 0;\n#else\n    struct statvfs buf;\n    if (statvfs(path.c_str(), &buf) == 0) {\n        return static_cast<uint64_t>(buf.f_bavail) * static_cast<uint64_t>(buf.f_frsize);\n    }\n    return 0;\n#endif\n}\n\nuint64_t FileUtils::get_total_space(const std::string& path) {\n#ifdef _WIN32\n    ULARGE_INTEGER total_bytes;\n    std::wstring wpath(path.begin(), path.end());\n    if (GetDiskFreeSpaceExW(wpath.c_str(), nullptr, &total_bytes, nullptr)) {\n        return total_bytes.QuadPart;\n    }\n    return 0;\n#else\n    struct statvfs buf;\n    if (statvfs(path.c_str(), &buf) == 0) {\n        return static_cast<uint64_t>(buf.f_blocks) * static_cast<uint64_t>(buf.f_frsize);\n    }\n    return 0;\n#endif\n}\n\nuint64_t FileUtils::get_free_space(const std::string& path) {\n#ifdef _WIN32\n    ULARGE_INTEGER free_bytes;\n    std::wstring wpath(path.begin(), path.end());\n    if (GetDiskFreeSpaceExW(wpath.c_str(), nullptr, nullptr, &free_bytes)) {\n        return free_bytes.QuadPart;\n    }\n    return 0;\n#else\n    struct statvfs buf;\n    if (statvfs(path.c_str(), &buf) == 0) {\n        return static_cast<uint64_t>(buf.f_bfree) * static_cast<uint64_t>(buf.f_frsize);\n    }\n    return 0;\n#endif\n}\n\nbool FileUtils::is_file_locked(const std::string& path) {\n#ifdef _WIN32\n    std::wstring wpath(path.begin(), path.end());\n    HANDLE hFile = CreateFileW(\n        wpath.c_str(),\n        GENERIC_READ,\n        0, // No sharing\n        nullptr,\n        OPEN_EXISTING,\n        FILE_ATTRIBUTE_NORMAL,\n        nullptr\n    );\n    \n    if (hFile == INVALID_HANDLE_VALUE) {\n        return GetLastError() == ERROR_SHARING_VIOLATION;\n    }\n    \n    CloseHandle(hFile);\n    return false;\n#else\n    // On Linux, check if file is locked by trying to acquire an exclusive lock\n    int fd = open(path.c_str(), O_RDONLY);\n    if (fd == -1) {\n        return false;\n    }\n    \n    struct flock lock;\n    lock.l_type = F_WRLCK;\n    lock.l_whence = SEEK_SET;\n    lock.l_start = 0;\n    lock.l_len = 0;\n    \n    bool locked = (fcntl(fd, F_GETLK, &lock) == -1) || (lock.l_type != F_UNLCK);\n    close(fd);\n    return locked;\n#endif\n}\n\nbool FileUtils::lock_file(file_handle_t handle) {\n    if (!is_valid_handle(handle)) {\n        return false;\n    }\n    \n#ifdef _WIN32\n    OVERLAPPED overlapped = {0};\n    return LockFileEx(handle, LOCKFILE_EXCLUSIVE_LOCK, 0, MAXDWORD, MAXDWORD, &overlapped) != FALSE;\n#else\n    struct flock lock;\n    lock.l_type = F_WRLCK;\n    lock.l_whence = SEEK_SET;\n    lock.l_start = 0;\n    lock.l_len = 0;\n    \n    return fcntl(handle, F_SETLK, &lock) != -1;\n#endif\n}\n\nbool FileUtils::unlock_file(file_handle_t handle) {\n    if (!is_valid_handle(handle)) {\n        return false;\n    }\n    \n#ifdef _WIN32\n    OVERLAPPED overlapped = {0};\n    return UnlockFileEx(handle, 0, MAXDWORD, MAXDWORD, &overlapped) != FALSE;\n#else\n    struct flock lock;\n    lock.l_type = F_UNLCK;\n    lock.l_whence = SEEK_SET;\n    lock.l_start = 0;\n    lock.l_len = 0;\n    \n    return fcntl(handle, F_SETLK, &lock) != -1;\n#endif\n}\n\nbool FileUtils::flush_file_buffers(file_handle_t handle) {\n    if (!is_valid_handle(handle)) {\n        return false;\n    }\n    \n#ifdef _WIN32\n    return FlushFileBuffers(handle) != FALSE;\n#else\n    return fsync(handle) == 0;\n#endif\n}\n\nbool FileUtils::truncate_file(file_handle_t handle, uint64_t size) {\n    if (!is_valid_handle(handle)) {\n        return false;\n    }\n    \n#ifdef _WIN32\n    LARGE_INTEGER liSize;\n    liSize.QuadPart = size;\n    return SetFilePointerEx(handle, liSize, nullptr, FILE_BEGIN) && SetEndOfFile(handle);\n#else\n    return ftruncate(handle, static_cast<off_t>(size)) == 0;\n#endif\n}\n\nuint32_t FileUtils::get_file_attributes(const std::string& path) {\n#ifdef _WIN32\n    std::wstring wpath(path.begin(), path.end());\n    return GetFileAttributesW(wpath.c_str());\n#else\n    struct stat st;\n    if (stat(path.c_str(), &st) == 0) {\n        return st.st_mode;\n    }\n    return 0;\n#endif\n}\n\nbool FileUtils::set_file_attributes(const std::string& path, uint32_t attributes) {\n#ifdef _WIN32\n    std::wstring wpath(path.begin(), path.end());\n    return SetFileAttributesW(wpath.c_str(), attributes) != FALSE;\n#else\n    return chmod(path.c_str(), attributes) == 0;\n#endif\n}\n\nbool FileUtils::get_file_times(const std::string& path, \n                              uint64_t& creation_time,\n                              uint64_t& last_write_time,\n                              uint64_t& last_access_time) {\n#ifdef _WIN32\n    std::wstring wpath(path.begin(), path.end());\n    WIN32_FILE_ATTRIBUTE_DATA attrs;\n    if (!GetFileAttributesExW(wpath.c_str(), GetFileExInfoStandard, &attrs)) {\n        return false;\n    }\n    \n    // Convert FILETIME to uint64_t\n    creation_time = (static_cast<uint64_t>(attrs.ftCreationTime.dwHighDateTime) << 32) | \n                   attrs.ftCreationTime.dwLowDateTime;\n    last_write_time = (static_cast<uint64_t>(attrs.ftLastWriteTime.dwHighDateTime) << 32) | \n                     attrs.ftLastWriteTime.dwLowDateTime;\n    last_access_time = (static_cast<uint64_t>(attrs.ftLastAccessTime.dwHighDateTime) << 32) | \n                      attrs.ftLastAccessTime.dwLowDateTime;\n    \n    return true;\n#else\n    struct stat st;\n    if (stat(path.c_str(), &st) != 0) {\n        return false;\n    }\n    \n    creation_time = static_cast<uint64_t>(st.st_ctime);\n    last_write_time = static_cast<uint64_t>(st.st_mtime);\n    last_access_time = static_cast<uint64_t>(st.st_atime);\n    \n    return true;\n#endif\n}\n\nbool FileUtils::set_file_times(const std::string& path,\n                             uint64_t creation_time,\n                             uint64_t last_write_time,\n                             uint64_t last_access_time) {\n#ifdef _WIN32\n    std::wstring wpath(path.begin(), path.end());\n    HANDLE hFile = CreateFileW(\n        wpath.c_str(),\n        FILE_WRITE_ATTRIBUTES,\n        FILE_SHARE_READ | FILE_SHARE_WRITE,\n        nullptr,\n        OPEN_EXISTING,\n        FILE_ATTRIBUTE_NORMAL,\n        nullptr\n    );\n    \n    if (hFile == INVALID_HANDLE_VALUE) {\n        return false;\n    }\n    \n    // Convert uint64_t to FILETIME\n    FILETIME ftCreation, ftLastWrite, ftLastAccess;\n    ftCreation.dwHighDateTime = static_cast<DWORD>(creation_time >> 32);\n    ftCreation.dwLowDateTime = static_cast<DWORD>(creation_time & 0xFFFFFFFF);\n    ftLastWrite.dwHighDateTime = static_cast<DWORD>(last_write_time >> 32);\n    ftLastWrite.dwLowDateTime = static_cast<DWORD>(last_write_time & 0xFFFFFFFF);\n    ftLastAccess.dwHighDateTime = static_cast<DWORD>(last_access_time >> 32);\n    ftLastAccess.dwLowDateTime = static_cast<DWORD>(last_access_time & 0xFFFFFFFF);\n    \n    BOOL result = SetFileTime(hFile, &ftCreation, &ftLastAccess, &ftLastWrite);\n    CloseHandle(hFile);\n    \n    return result != FALSE;\n#else\n    struct utimbuf times;\n    times.actime = static_cast<time_t>(last_access_time);\n    times.modtime = static_cast<time_t>(last_write_time);\n    \n    return utime(path.c_str(), &times) == 0;\n#endif\n}